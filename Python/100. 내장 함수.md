# python 내장 함수에 대한 정리

## 복사, copy()  
list 는 다른 변수에 할당해도 이름만 바뀔 뿐 같은 리스트(객체)를 가리키게 된다.

2차원 리스트/배열도 마찬가지 결과를 보인다.  

다음의 예제 코드를 살펴보자.

```py
>>> A = [[10, 20], [30, 40]]
>>> B = A
>>> B[0][0] = 500
>>> A
[[500, 20], [30, 40]]
>>> B
[[500, 20], [30, 40]]
```

한편 리스트 A를 copy 메서드로 B에 복사한 뒤 B의 요소를 변경해보면 리스트 A와 B에 모두 반영된다.

```py
>>> A = [[10, 20], [30, 40]]
>>> B = A.copy()
>>> B[0][0] = 500
>>> A
[[500, 20], [30, 40]]
>>> B
[[500, 20], [30, 40]]
```

따라서 2차원 이상의 다차원 리스트는 리스트를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 한다.

```py
>>> A = [[10, 20], [30, 40]]
>>> import copy             # copy 모듈을 가져옴
>>> B = copy.deepcopy(a)    # copy.deepcopy 함수를 사용하여 깊은 복사
>>> B[0][0] = 500
>>> A
[[10, 20], [30, 40]]
>>> B
[[500, 20], [30, 40]]
```

이제 리스트 B의 요소를 변경해도 리스트 A에는 영향을 미치지 않습니다.  
copy.deepcopy 함수는 중첩된 리스트(튜플)에 들어있는 모든 리스트(튜플)를 복사하는 깊은 복사(deep copy)를 해준다.

## enumerate()  
: 단순히 `for 문`을 사용하는 것에 더하여 인덱스와 원소를 동시에 반환할 수 있다.  

다음의 예제를 살펴보자
```py
for letter in ['A', 'B', 'C']:
    print(letter)
# 출력 - A \n B \n C \n
for entry in enumerate(['A', 'B', 'C']):
    print(entry)
# 출력 - (0, 'A') \n (1, 'B') \n (2, 'C')
for i, letter in enumerate(['A', 'B', 'C']):
    print(i, letter)
# 출력 - 0 A \n 1 B \n 2 C 
```  

만약 시작 인덱스를 변경하고 싶다면 함수 호출 시 `start` 인자에 넣어주면 된다.

추가로 다음의 2차원 루프를 살펴보자.
```py
for r in range(len(matrix)):
    for c in range(len(matrix[r])):
        print(r, c, matrix[r][c])
# 출력
# 0 0 A
# 0 1 B
# 0 2 C
# 1 0 D
# ...
```
